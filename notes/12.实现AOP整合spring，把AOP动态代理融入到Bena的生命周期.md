# 一、目标
在上一章节中，我们基于Proxy.newProxyInstance代理操作中处理方法匹配和方法拦截，对匹配的对象进行自定义的处理操作。

在有了一个AOP核心功能的实现后，我们可以通过单元测试的方式进行验证切面功能对方法的拦截和处理，但如果这是一个面向用户使用的功能，就不太可能让用户进行这么复杂且没有与Spring结合的方式来单独使用AOP。

因此，我们需要在本章节完成AOP核心功能与原有Spring框架的整合，最终能通过在Spring的配置的方式完成切面的操作。
# 二、设计
想要把AOP的核心功能整合到Spring中，有以下几个问题：
- 怎么借着BeanPostProcessor把动态代理融入到Bean的生命周期中
- 如何组装各项切入点、拦截、前置的功能和适配对应的代理器

具体设计：
- 为了可以让对象创建过程中，能把xml中配置的代理对象也就是切面的一些类对象实例化，就需要用到BeanPostProcessor提供的方法，因为这个类的方法可以分别作用于Bean对象执行初始化前后修改Bean对象的扩展信息。
但是这里需要集合于BeanPostProcessor实现新的接口和实现类，这样才能定向获取对应的类信息。
- 因为创建的对象是代理对象而不是之前的普通对象，所以我们需要前置于其他对象的创建，在实际开发中，需要在createBean方法中优先完成Bean对象的判断，是否需要代理，是的话则直接返回代理对象。
  （在Spring源码中，是分为createBean和doCreateBean的方法拆分）
- 这里还包括要解决方法拦截器的具体功能，提供一些BeforeAdvice、AfterAdvice的实现。以及需要包装切面表达式以及拦截方法的整合，提供不同类型的代理方式的代理工厂，包装我们的切面服务。

# 三、实现
具体实现如下：
- 在以BeanPostProcessor接口继承的InstantiationAwareBeanPostProcessor接口下面，做了一个自动代理创建的实现类DefaultAdvisorAutoProxyCreator，这个类就是用于处理整个AOP代理融入到Bean生命周期的核心类
- DefaultAdvisorAutoProxyCreator会依赖于拦截器、代理工厂，以及整合Pointcut与Advisor的包装服务AspectJExpressionPointcutAdvisor，由它提供切面、拦截方法和表达式
- Spring的AOP把Advice细化了BeforeAdvice、AfterAdvice、AfterReturningAdvice、ThrowsAdvice，目前我们做的只是BeforeAdvice
